function t(){let t;return[new Promise(((e,s)=>{t=e})),t]}const e=4;class s{constructor(t,e={}){this._url=t,this._ws,this._connecting=!1,this._connected=!1,this._options=e,this._retries=0,this._connect_promise_resolvers=[]}get connecting(){return this._connecting}get connected(){return this._connected}get url(){return this._url}get options(){return this._options}connect(){this.connecting||this.connected?console.log("Connect while connecting or connected"):this._is_terminated()?console.log("Terminated"):(this._ws=new WebSocket(this._url),this._connecting=!0,this._ws.onopen=t=>this._on_open(t),this._ws.onmessage=t=>this.on_message(t.data),this._ws.onclose=t=>this._on_close(t),this._ws.onerror=t=>this.on_error(t),this.on_connecting())}_on_open(t){this._connecting=!1,this._connected=!0;for(const t of this._connect_promise_resolvers)t();this._connect_promise_resolvers=[],this._retries=0,this.on_connect()}_on_close(t){this._connecting=!1,this._connected=!1,this.on_disconnect(t),this._retries+=1,this._is_terminated()||setTimeout((()=>{this.connect()}),1e3*this._retries)}_is_terminated(){const{retries:t=e}=this._options;return this._retries>=t&&(console.log(`Terminated: Max retries reached (${t})`),this._connecting=!1,this._connected=!0,this._ws.onopen=void 0,this._ws.onmessage=void 0,this._ws.onclose=void 0,this._ws.onerror=void 0,this._ws=void 0,!0)}on_connecting(){const{debug:t=!1}=this._options;t&&console.log(`Connecting ${this.url}`)}on_connect(){console.log(`Connect  ${this.url}`)}on_error(t){const{debug:e=!1}=this._options;e&&console.log(`Error: ${t}`)}on_disconnect(t){console.error(`Disconnect ${this.url}`)}on_message(t){const{debug:e=!1}=this._options;e&&console.log(`Receive: ${t}`)}send(t){if(this._connected)try{this._ws.send(t)}catch(t){console.error(`Send fail: ${t}`)}else console.log("Send drop : not connected")}connectedPromise(){const[e,s]=t();return this.connected?s():this._connect_promise_resolvers.push(s),e}}class n{constructor(t,e){this._ssclient=t,this._path=e,this._handlers=[],this._map=new Map}_ssclient_update(t={}){const{remove:e,insert:s,reset:n=!1}=t,i=new Map;if(n){for(const t of this._map.values())i.set(t.id,{id:t.id,new:void 0,old:t});this._map=new Map}else for(const t of e){const e=this._map.get(t);null!=e&&(this._map.delete(t),i.set(t,{id:t,new:void 0,old:e}))}for(const t of s){const e=t.id,s=i.get(e),n=null!=s?s.old:this._map.get(e);this._map.set(e,t),i.set(e,{id:e,new:t,old:n})}this._notify_callbacks([...i.values()])}_notify_callbacks(t){this._handlers.forEach((function(e){e.handler(t)}))}get_items(){return[...this._map.values()]}get size(){return this._map.size}get_item(t){return this._map.get(t)}has_item(t){return this._map.has(t)}update(t={}){return this._ssclient.update(this._path,t)}add_callback(t){const e={handler:t};return this._handlers.push(e),e}remove_callback(t){const e=this._handlers.indexOf(t);e>-1&&this._handlers.splice(e,1)}}const i=Object.freeze({MESSAGE:"MESSAGE",REQUEST:"REQUEST",REPLY:"REPLY"}),o=Object.freeze({GET:"GET",PUT:"PUT",NOTIFY:"NOTIFY"});class _ extends s{constructor(t,e){super(t,e),this._reqid=0,this._pending=new Map,this._subs_map=new Map,this._ds_map=new Map,this._ds_handle_map=new Map}on_connect(){if(console.log(`Connect  ${this.url}`),this._subs_map.size>0){const t=[...this._subs_map.entries()];this.update("/subs",{insert:t,reset:!0})}}on_disconnect(){console.error(`Disconnect ${this.url}`)}on_error(t){const{debug:e=!1}=this._options;e&&console.log(`Communication Error: ${t}`)}on_message(t){let e=JSON.parse(t);if(e.type==i.REPLY){let t=e.tunnel;if(this._pending.has(t)){let s=this._pending.get(t);this._pending.delete(t);const{ok:n,data:i}=e;s({ok:n,data:i})}}else e.type==i.MESSAGE&&e.cmd==o.NOTIFY&&this._handle_notify(e)}_handle_notify(t){const e=this._ds_map.get(t.path);null!=e&&e._ssclient_update(t.data)}_request(e,s,n){const _=this._reqid++,r={type:i.REQUEST,cmd:e,path:s,arg:n,tunnel:_};this.send(JSON.stringify(r));let[c,h]=t();return this._pending.set(_,h),c.then((({ok:t,data:n})=>(e==o.PUT&&"/subs"==s&&t&&(this._subs_map=new Map(n)),{ok:t,path:s,data:n})))}_sub(t){if(this.connected){new Map([...this._subs_map]).set(t,{});const e=[...this._subs_map.entries()];return this.update("/subs",{insert:e,reset:!0})}return this._subs_map.set(t,{}),Promise.resolve({ok:!0,path:t,data:void 0})}_unsub(t){const e=new Map([...this._subs_map]);e.delete(t);const s=[...e.entries()];return this.update("/subs",{insert:s,reset:!0})}get(t){return this._request(o.GET,t)}update(t,e){return this._request(o.PUT,t,e)}acquire(t){this._subs_map.has(t)||this._sub(t),this._ds_map.has(t)||this._ds_map.set(t,new n(this,t));const e=this._ds_map.get(t),s={path:t};return this._ds_handle_map.has(t)||this._ds_handle_map.set(t,[]),this._ds_handle_map.get(t).push(s),[s,e]}release(t){const e=t.path,s=this._ds_handle_map.get(e);if(null==s)return;const n=s.indexOf(t);n>-1&&s.splice(n,1),0==s.length&&(this._unsub(e),this._ds_map.delete(e))}}function r(t){const{id:e,itv:s,data:n}=t;let i=JSON.stringify(n);return`\n        <div>\n            <button id="delete">X</button>\n            ${`<span class="id">${e}</span>`}: ${`<span class="itv">${null!=s?JSON.stringify(s):""}</span>`} ${`<span class="data">${i}</span>`}\n        </div>`}class c{constructor(t,e,s={}){this._ds=t,this._elem=e,this._ds.add_callback(this._onchange.bind(this));let n={delete:!1,toString:r};this._options={...n,...s},this._options.delete&&e.addEventListener("click",(t=>{const e=t.target.closest("#delete");if(e){const s=e.closest(".list-item");s&&(this._ds.update({remove:[s.id]}),t.stopPropagation())}}))}_onchange(t){const{toString:e}=this._options;for(let s of t)if(s.new){let t=this._elem.querySelector(`#${s.id}`);null==t&&(t=document.createElement("div"),t.setAttribute("id",s.id),t.classList.add("list-item"),this._elem.appendChild(t)),t.innerHTML=e(s.new)}else if(s.old){let t=this._elem.querySelector(`#${s.id}`);t&&t.parentNode.removeChild(t)}}}export{c as DatasetViewer,_ as SharedStateClient};
