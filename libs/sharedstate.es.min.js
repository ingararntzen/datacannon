function t(){let t;return[new Promise(((s,e)=>{t=s})),t]}const s=4;class e{constructor(t,s={}){this._url=t,this._ws,this._connecting=!1,this._connected=!1,this._options=s,this._retries=0,this._connect_promise_resolvers=[]}get connecting(){return this._connecting}get connected(){return this._connected}get url(){return this._url}get options(){return this._options}connect(){this.connecting||this.connected?console.log("Connect while connecting or connected"):this._is_terminated()?console.log("Terminated"):(this._ws=new WebSocket(this._url),this._connecting=!0,this._ws.onopen=t=>this._on_open(t),this._ws.onmessage=t=>this.on_message(t.data),this._ws.onclose=t=>this._on_close(t),this._ws.onerror=t=>this.on_error(t),this.on_connecting())}_on_open(t){this._connecting=!1,this._connected=!0;for(const t of this._connect_promise_resolvers)t();this._connect_promise_resolvers=[],this._retries=0,this.on_connect()}_on_close(t){this._connecting=!1,this._connected=!1,this.on_disconnect(t),this._retries+=1,this._is_terminated()||setTimeout((()=>{this.connect()}),1e3*this._retries)}_is_terminated(){const{retries:t=s}=this._options;return this._retries>=t&&(console.log(`Terminated: Max retries reached (${t})`),this._connecting=!1,this._connected=!0,this._ws.onopen=void 0,this._ws.onmessage=void 0,this._ws.onclose=void 0,this._ws.onerror=void 0,this._ws=void 0,!0)}on_connecting(){const{debug:t=!1}=this._options;t&&console.log(`Connecting ${this.url}`)}on_connect(){console.log(`Connect  ${this.url}`)}on_error(t){const{debug:s=!1}=this._options;s&&console.log(`Error: ${t}`)}on_disconnect(t){console.error(`Disconnect ${this.url}`)}on_message(t){const{debug:s=!1}=this._options;s&&console.log(`Receive: ${t}`)}send(t){if(this._connected)try{this._ws.send(t)}catch(t){console.error(`Send fail: ${t}`)}else console.log("Send drop : not connected")}connectedPromise(){const[s,e]=t();return this.connected?e():this._connect_promise_resolvers.push(e),s}}class n{constructor(t,s){this._ssclient=t,this._path=s,this._handlers=[],this._map=new Map}_ssclient_update(t={}){const{remove:s,insert:e,reset:n=!1}=t,i=new Map;if(n){for(const t of this._map.values())i.set(t.id,{id:t.id,new:void 0,old:t});this._map=new Map}else for(const t of s){const s=this._map.get(t);null!=s&&(this._map.delete(t),i.set(t,{id:t,new:void 0,old:s}))}for(const t of e){const s=t.id,e=i.get(s),n=null!=e?e.old:this._map.get(s);this._map.set(s,t),i.set(s,{id:s,new:t,old:n})}this._notify_callbacks([...i.values()])}_notify_callbacks(t){this._handlers.forEach((function(s){s.handler(t)}))}get_items(){return[...this._map.values()]}get size(){return this._map.size}get_item(t){return this._map.get(t)}has_item(t){return this._map.has(t)}update(t={}){return this._ssclient.update(this._path,t)}add_callback(t){const s={handler:t};return this._handlers.push(s),s}remove_callback(t){const s=this._handlers.indexOf(t);s>-1&&this._handlers.splice(s,1)}}const i=function(){return performance.now()/1e3},o=function(){return new Date/1e3},_=function(){const t=i(),s=o();return{now:function(){const e=i();return s+(e-t)}}}();class r{constructor(t){this._ssclient=t,this._pinger=new h(this._onping.bind(this)),this._samples=[],this._trans=1e3,this._skew=0}resume(){this._pinger.resume()}pause(){this._pinger.pause()}_onping(){const t=_.now();this._ssclient.get("/clock").then((({data:s})=>{const e=_.now();this._add_sample(t,s,e)}))}_add_sample(t,s,e){let n=(e-t)/2,i=s-(e+t)/2,o=[t,s,e,n,i];this._samples.push(o),this._samples.length>30&&this._samples.shift(),n=1e5,i=0;for(const t of this._samples)t[3]<n&&(n=t[3],i=t[4]);this._skew=i,this._trans=n}get skew(){return this._skew}get trans(){return this._trans}now(){return _.now()+this._skew}}const c=[...new Array(3).fill(20),...new Array(7).fill(500),1e4];class h{constructor(t){this._count=0,this._tid=void 0,this._callback=t,this._ping=this.ping.bind(this),this._delays=[...c]}pause(){clearTimeout(this._tid)}resume(){clearTimeout(this._tid),this.ping()}restart(){this._delays=[...c],clearTimeout(this._tid),this.ping()}ping(){let t=this._delays[0];this._delays.length>1&&this._delays.shift(),this._callback&&this._callback(),this._tid=setTimeout(this._ping,t)}}const a=Object.freeze({MESSAGE:"MESSAGE",REQUEST:"REQUEST",REPLY:"REPLY"}),l=Object.freeze({GET:"GET",PUT:"PUT",NOTIFY:"NOTIFY"});class d extends e{constructor(t,s){super(t,s),this._reqid=0,this._pending=new Map,this._subs_map=new Map,this._ds_map=new Map,this._ds_handle_map=new Map,this._clock=new r(this)}on_connect(){if(this._clock.resume(),console.log(`Connect  ${this.url}`),this._subs_map.size>0){const t=[...this._subs_map.entries()];this.update("/subs",{insert:t,reset:!0})}}on_disconnect(){this._clock.pause(),console.error(`Disconnect ${this.url}`)}on_error(t){const{debug:s=!1}=this._options;s&&console.log(`Communication Error: ${t}`)}on_message(t){let s=JSON.parse(t);if(s.type==a.REPLY){let t=s.tunnel;if(this._pending.has(t)){let e=this._pending.get(t);this._pending.delete(t);const{ok:n,data:i}=s;e({ok:n,data:i})}}else s.type==a.MESSAGE&&s.cmd==l.NOTIFY&&this._handle_notify(s)}_handle_notify(t){const s=this._ds_map.get(t.path);null!=s&&s._ssclient_update(t.data)}_request(s,e,n){const i=this._reqid++,o={type:a.REQUEST,cmd:s,path:e,arg:n,tunnel:i};this.send(JSON.stringify(o));let[_,r]=t();return this._pending.set(i,r),_.then((({ok:t,data:n})=>(s==l.PUT&&"/subs"==e&&t&&(this._subs_map=new Map(n)),{ok:t,path:e,data:n})))}_sub(t){if(this.connected){new Map([...this._subs_map]).set(t,{});const s=[...this._subs_map.entries()];return this.update("/subs",{insert:s,reset:!0})}return this._subs_map.set(t,{}),Promise.resolve({ok:!0,path:t,data:void 0})}_unsub(t){const s=new Map([...this._subs_map]);s.delete(t);const e=[...s.entries()];return this.update("/subs",{insert:e,reset:!0})}get(t){return this._request(l.GET,t)}update(t,s){return this._request(l.PUT,t,s)}acquire(t){this._subs_map.has(t)||this._sub(t),this._ds_map.has(t)||this._ds_map.set(t,new n(this,t));const s=this._ds_map.get(t),e={path:t};return this._ds_handle_map.has(t)||this._ds_handle_map.set(t,[]),this._ds_handle_map.get(t).push(e),[e,s]}release(t){const s=t.path,e=this._ds_handle_map.get(s);if(null==e)return;const n=e.indexOf(t);n>-1&&e.splice(n,1),0==e.length&&(this._unsub(s),this._ds_map.delete(s))}get clock(){return this._clock}}function p(t){const{id:s,itv:e,data:n}=t;let i=JSON.stringify(n);return`\n        <div>\n            <button id="delete">X</button>\n            ${`<span class="id">${s}</span>`}: ${`<span class="itv">${null!=e?JSON.stringify(e):""}</span>`} ${`<span class="data">${i}</span>`}\n        </div>`}class u{constructor(t,s,e={}){this._ds=t,this._elem=s,this._ds.add_callback(this._onchange.bind(this));let n={delete:!1,toString:p};this._options={...n,...e},this._options.delete&&s.addEventListener("click",(t=>{const s=t.target.closest("#delete");if(s){const e=s.closest(".list-item");e&&(this._ds.update({remove:[e.id]}),t.stopPropagation())}}))}_onchange(t){const{toString:s}=this._options;for(let e of t)if(e.new){let t=this._elem.querySelector(`#${e.id}`);null==t&&(t=document.createElement("div"),t.setAttribute("id",e.id),t.classList.add("list-item"),this._elem.appendChild(t)),t.innerHTML=s(e.new)}else if(e.old){let t=this._elem.querySelector(`#${e.id}`);t&&t.parentNode.removeChild(t)}}}export{u as DatasetViewer,d as SharedStateClient};
